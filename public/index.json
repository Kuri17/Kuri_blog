[{"content":"解けたのはh0lyTの1問のみ．平方剰余とCRT(中国剰余定理)を使ったいい問題だった．\nhOlyT(141 solves / 422 points) code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 from Crypto.Util.number import getPrime, bytes_to_long import random def legendre(a, p): return pow(a, (p - 1) // 2, p) def tonelli(n, p): q = p - 1 s = 0 while q % 2 == 0: q //= 2 s += 1 if s == 1: return pow(n, (p + 1) // 4, p) for z in range(2, p): if p - 1 == legendre(z, p): break c = pow(z, q, p) r = pow(n, (q + 1) // 2, p) t = pow(n, q, p) m = s t2 = 0 while (t - 1) % p != 0: t2 = (t * t) % p for i in range(1, m): if (t2 - 1) % p == 0: break t2 = (t2 * t2) % p b = pow(c, 1 \u0026lt;\u0026lt; (m - i - 1), p) r = (r * b) % p c = (b * b) % p t = (t * c) % p m = i return r def xgcd(a, b): if a == 0 : return 0,1 x1,y1 = xgcd(b%a, a) x = y1 - (b//a) * x1 y = x1 return x,y def crt(a, b, m, n): m1, n1 = xgcd(m, n) return ((b *m * m1 + a *n*n1) % (m * n)) def advice(x, p, q): if legendre(x, p) != 1: exit() if legendre(x, q) != 1: exit() x1 = tonelli(x, p) * random.choice([1, -1]) x2 = tonelli(x, q) * random.choice([1, -1]) y = crt(x1, x2, p, q) return y def main(): p = getPrime(1024) q = getPrime(1024) N = p * q e = 65537 m = bytes_to_long(b\u0026#34;lactf{redacted?}\u0026#34;) ct = pow(m, e, N) print(f\u0026#34;ct = {ct}\u0026#34;) print(f\u0026#34;N = {N}\u0026#34;) print(f\u0026#34;e = {e}\u0026#34;) while 1: x = int(input(\u0026#34;What do you want to ask? \u0026gt; \u0026#34;)) ad = advice(x, p, q) print(ad) if __name__ == \u0026#34;__main__\u0026#34;: main() RSA暗号と同じようにメッセージmが暗号化され，暗号文としてctが渡されるので，\\(N\\)の素因数の\\(p,q\\)を求める． $$ ct　\\equiv m^e \\mod N(pq) $$ 問題には\\(p,q\\)についての情報を教えてくれる関数adviceが用意されており，任意の値\\(x\\)を入力し，出力から解読する．adviceは以下の関数．\nadivce 入力\\(x \\in pq\\)を受け取る． \\(x \\equiv a^2 \\mod p, x \\equiv b^2 \\mod q \\)となる\\((a,b)\\)が存在するとき次のステップに進む \\(a' \\in \\{x,p-a\\},b' \\in \\{b,q-b\\}\\)から，CRTで\\(X \\in \\{0,\\dots,pq-1\\}\\)を出力する． $$X \\equiv a' \\mod p $$ $$X \\equiv b' \\mod q$$ solution どんな法\\(p\\)でも，\\(1 \\equiv 1^2 \\mod p\\)であるので，\\(x\\)には\\(1\\)を選ぶ．そして出力\\(X\\)は\\((a',b')\\)の選び方から4通り有るが，\n\\((a',b') = (1,q-1)\\)のとき $$ X+1 \\equiv 0 \\mod q $$ \\((a',b') = (1,q-1)\\)のとき $$ X+1 \\equiv 0 \\mod q$$ であるから\\(gcd(X +1,N)=(p ~or ~q) \\)で\\(p,q\\)が求まり問題が解ける．\n以下解いたコード\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from Crypto.Util.number import long_to_bytes a = 17831104667040256134725887251427780309283441190346378241363820041577227275015801947889351608323543022862201231205425355290220006633567994093510271341296137236696435486220210052887153794743228135603531011013817226919624495642090379006823492988501642462491665647285840701843758122419384518395935175111969431981176852184961902749819593573017708973408100060762005631607410042285600792954074826599343773206465846004997125247332792765111462262606314067259767823386343138746280621268625953047895333695773948796251064112811522554255832429054369092856990234149099315668149570501794323907590910167206485076585099237050507816158 b=5287777601238293523981811494581220691303194637423961140491216223083428308956095244834202549311570881496889752712676367619031571275642899318497063185249821345647331101077718320085534011766574399534626275869397780756135151510387353887061619044081762336730157777890978513661037167287196170717083630998547728678442124653719323218496331423510274573038831528686967059211961114374256096552045957173457049642231463409924134243522665941512000838223624978949908822912588169844952533849109925131151795615090030577149003683343962388502388786278395259552288577776773741360197776419851637543495068989503487348052288499709046665144 c=12543327065801962610744075756846559617980246552922417100872603818493798966059706703055149059011972141365311478492748987671188435357925094775013208156046315891049104385142491732801619782976653736068904735144419446163489344131703025119761873944419880125761507869394862188182720955132188347678851544113421703302734727531242579531323262149507434400369268532075038572395448927911344696402028869425886723564234382595072991003810126823599461424382689088309859000473754968901328087419516027916743538080683918219102060429467560165753443642775973833304701656372325574307951794081942686364095841177702997728532810737341461151015 ct =7795478703951910298760800512251016604742954197898050479871934501928567145784802604542002268080404992780678217646124951840673797270491710309688112924721561151731605873112953711785868170966477869814463719384874577110299248963713396172759754647405773964179242806311505685143222093888093347835985735639754440152848146516109884968142336041568834166265316368983280221226951298952481486521619997411247561491239782604374151098554182647251791561517307089804991475650432858727962467022168414859936296189874338448996484184334288550871046087698350678567999518807001116688026839842507335016985102010047274042512865191879615627189 N = 17831104667040256134725887251427780309283441190346378241363820041577227275015801947889351608323543022862201231205425355290220006633567994093510271341296137236696435486220210052887153794743228135603531011013817226919624495642090379006823492988501642462491665647285840701843758122419384518395935175111969431981176852184961902749819593573017708973408100060762005631607410042285600792954074826599343773206465846004997125247332792765111462262606314067259767823386343138746280621268625953047895333695773948796251064112811522554255832429054369092856990234149099315668149570501794323907590910167206485076585099237050507816159 e = 65537 print() for i in [a,b,c]: p = gcd(N,i+1) q = N//p d = pow(e,-1,(p-1)*(q-1)) print(long_to_bytes(int(pow(ct,int(d),N)))) ","permalink":"http://localhost:1313/kuri_blog/posts/lactf/","summary":"lactf2024 writeup","title":"Lactf2024"},{"content":"37C3 Potluck CTF 2023/12/29に開催されたCTFのwriteup.\nlima beans with lemon and lime(184pt) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python3 from Crypto.Util.number import getPrime, bytes_to_long from secrets import randbelow, randbits # from FLAG import flag beanCount = 8 beanSize = 2048 lemonSize = beanSize // 2 * beanCount killerBean = getPrime(beanSize) queries = 17 def pkcs16(limaBeans): filledLimaBeans = [0 for _ in range(beanCount)] #flagに足す limaBeans += b\u0026#39;A\u0026#39; * ((beanCount * beanSize // 8) - len(limaBeans)) #flagをintに cookedLimaBeans = bytes_to_long(limaBeans) for idx in range(beanCount): cookedLimaBeans, filledLimaBeans[idx] = divmod(cookedLimaBeans, killerBean)# divmod(a,b) = a//b,a%b return filledLimaBeans #filledLimaBeans[0]= bytes_to_long(limaBeans) % killerBean,#filledLimaBeans[1]= bytes_to_long(limaBeans) // KillererBean) % killerBean, def encrypt(limaBeans, lemon, lime): limaBeansWithLemonAndLime = 0 for idx in range(beanCount): lemonSlice = lemon[idx] limaBean = limaBeans[idx] if (lime \u0026gt;\u0026gt; idx) \u0026amp; 1: limaBean **= 2 limaBean %= killerBean limaBeansWithLemonAndLime += limaBean * lemonSlice limaBeansWithLemonAndLime %= killerBean\treturn limaBeansWithLemonAndLime flag = pkcs16(flag) print(f\u0026#39;Hello and welcome to the lima beans with lemon and lime cryptosystem. It it so secure that it even has a {lemonSize} bit encryption key, that is {lemonSize // 256} times bigger than an AES-256, and therefore is {lemonSize // 256} times more secure\u0026#39;) print(f\u0026#39;p: {killerBean}\u0026#39;) for turn in range(queries): print(\u0026#39;1: Encrypt a message\\n2: Encrypt flag\\n3: Decrypt message\u0026#39;) choice = input(\u0026#39;\u0026gt; \u0026#39;) if choice not in (\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;): print(\u0026#39;What?\u0026#39;) if choice == \u0026#39;1\u0026#39;:#angouotamesi limaBeans = input(\u0026#39;msg: \u0026#39;).encode() #limabeansは2048bit以下である必要がある if len(limaBeans) * 8 \u0026gt; beanSize * beanCount: print(\u0026#39;Hmmm a bit long innit?\u0026#39;) continue limaBeans = pkcs16(limaBeans) lemon = [randbelow(2**(beanSize - 48)) for _ in range(beanCount)] lime = randbits(beanCount) limaBeansWithLemonAndLime = encrypt(limaBeans, lemon, lime) print(f\u0026#39;ct: {limaBeansWithLemonAndLime}\u0026#39;) print(f\u0026#39;iv: {lime}\u0026#39;) print(f\u0026#39;key: {\u0026#34;,\u0026#34;.join(map(str, lemon))}\u0026#39;) elif choice == \u0026#39;2\u0026#39;:#flag lemon = [randbelow(2**(beanSize//2)) for _ in range(beanCount)] lime = randbits(beanCount) limaBeansWithLemonAndLime = encrypt(flag, lemon, lime) print(f\u0026#39;ct: {limaBeansWithLemonAndLime}\u0026#39;) print(f\u0026#39;iv: {lime}\u0026#39;) print(f\u0026#39;key: {\u0026#34;,\u0026#34;.join(map(str, lemon))}\u0026#39;) else: print(\u0026#39;patented, sorry\u0026#39;) flagは与えられたファイル内のはpkcs16,encryptによって暗号化される．以下2つの関数の説明．\npkcs16 flagが2048byte文字列となるようにバイト文字列b\u0026rsquo;A\u0026rsquo;を後ろに追加し，整数にした値を\\(c\\)とする． 既知の2048bitの整数\\(k\\)で以下の計算を行う \\[ \\begin{aligned} c \u0026= k* r_1 + q_1\\\\ r_1 \u0026= k* r_2 + q_2\\\\ r_2 \u0026= k* r_3 + q_3\\\\ \u0026~~~\\vdots\\\\ r_8 \u0026= k* r_7 + q_8 \\end{aligned} \\] 3.\\(q_1,q_2,\\dots,q_8\\)を出力する．\n\\(r_{i-1}\\text{に}r_i\\)を代入していくと\\(c\\)の式で未知の数は\\(r_8\\)のみとなる． $$c　=$$ ","permalink":"http://localhost:1313/kuri_blog/posts/polkctf/","summary":"37C3 Potluck CTF 2023/12/29に開催されたCTFのwriteup. lima beans with lemon and lime(184pt) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33","title":"Polkctf"},{"content":"工藤と申します。CTF\n","permalink":"http://localhost:1313/kuri_blog/posts/hello/","summary":"工藤と申します。CTF","title":"Hello"}]